#[allow(non_snake_case)]
pub mod Manifest {
    use std::{fs, io};

    use crate::optimized_tree::OptimizedTreeContainer;
    use crate::sky::CloudPlugin;
    use crate::utils::format_js;
    use crate::CompileContext;
    use densky_adapter::utils::join_paths;
    use densky_adapter::CloudManifestUpdate;

    /// Generate TS code for this node and children
    fn build_node(
        id: u64,
        plugin: &CloudPlugin,
        container: &OptimizedTreeContainer,
    ) -> CloudManifestUpdate {
        let mut updates = CloudManifestUpdate::new();
        let node = container.nodes.get_reader(id).unwrap();

        let mut static_children = String::new();
        let mut children = String::new();

        for (pathname, id) in node.static_children.iter() {
            let children_update = build_node(*id, plugin, container);

            static_children.reserve_exact(pathname.len() + 13);
            static_children.push('"');
            static_children += pathname;
            static_children.push_str("\": () => {");
            static_children += &children_update.content().unwrap_or(&String::new());
            static_children.push('}');
            static_children.push(',');

            updates += children_update;
        }

        for (_, id) in node.dynamic_children.iter() {
            let children_update = build_node(*id, plugin, container);
            children += &children_update.content().unwrap_or(&String::new());

            updates += children_update;
        }

        let dynamic_child = if let Some((id, varname)) = node.dynamic.as_ref() {
            let mut child = container.nodes.get_writer(*id).unwrap();
            child.varname = Some(varname.clone());
            drop(child);

            build_node(*id, plugin, container)
        } else {
            CloudManifestUpdate::new()
        };

        updates += &dynamic_child;

        let binding = String::new();
        let dynamic_child = dynamic_child.content().unwrap_or(&binding);

        let leaf = node.into_leaf(container);
        let plugin_updates = unsafe {
            plugin
                .cloud_optimized_manifest_call(
                    leaf,
                    static_children,
                    children,
                    dynamic_child.to_string(),
                )
                .unwrap()
        };

        updates += &plugin_updates;

        updates = if let Some(content) = &plugin_updates.content() {
            updates.set_content(content.to_string())
        } else {
            updates
        };

        updates
    }

    /// Generate a manifest file from a container.
    fn build(plugin: &CloudPlugin, container: &OptimizedTreeContainer) -> String {
        let mut imports = String::new();
        let mut args = String::new();
        let mut content = String::new();

        let before_updates = unsafe { plugin.cloud_before_manifest() };

        if let Some(before_updates) = before_updates {
            for import in before_updates.imports() {
                imports += &format!("import {} from \"{}\";\n", import.1, import.0);
            }

            for arg in before_updates.arguments() {
                args += &format!("{}: {}", arg.0, arg.1);
            }

            if let Some(c) = before_updates.content() {
                content += c;
            }
        }

        let root = build_node(container.get_root_id().unwrap(), plugin, &container);

        for import in root.imports() {
            imports += &format!("import {} from \"{}\";\n", import.1, import.0);
        }

        for arg in root.arguments() {
            args += &format!("{}: {}", arg.0, arg.1);
        }

        if let Some(c) = root.content() {
            content += c;
        }

        format_js(format!(
            "
// This file is generated by Densky-Framework
// manifest.ts
{imports}

export default function({args}) {{
    {content}
}}"
        ))
    }

    /// Generate and write a manifest file from a container
    pub fn update(
        container: &OptimizedTreeContainer,
        plugin: &CloudPlugin,
        context: &CompileContext,
    ) -> io::Result<()> {
        let manifest = build(plugin, container);

        fs::write(join_paths("manifest.ts", &context.output_dir), manifest)
    }
}
